import AsciiPlistParser

{% for type in types.implementing.AutoPbxSubscript %}
// MARK: {{ type.name }}
extension {{ type.name }} {
{% for t in type.containedTypes %}
{% if t.kind == "enum" %}
    {% if t.name|hasSuffix:".StringField" %}
    subscript(field: StringField) -> String {
        set(newValue) {
            if let keyref = object.keyRef(for: field.rawValue) {
                let existing = object[keyref] as! StringValue
                existing.value = newValue
                object[keyref] = existing
            } else {
                let keyref = KeyRef(value: field.rawValue, annotation: nil)
                object[keyref] = newValue
            }
        }
        get {
            return object.string(for: field.rawValue)!
        }
    }
    {% endif %}
    {% if t.name|hasSuffix:".ArrayField" %}
    subscript(field: ArrayField) -> [StringValue] {
        set(newValue) {
            if let keyref = object.keyRef(for: field.rawValue) {
                let existing = object[keyref] as! ArrayValue
                existing.value = newValue
                object[keyref] = existing
            } else {
                let keyref = KeyRef(value: field.rawValue, annotation: nil)
                object[keyref] = newValue
            }
        }
        get {
            return object.arrayValue(for: field.rawValue)!.value
        }
    }
    {% endif %}
    {% if t.name|hasSuffix:".ObjectField" %}
    subscript(field: ObjectField) -> Object {
        set(newValue) {
            let keyref = object.keyRef(for: field.rawValue)!
            object[keyref] = newValue
        }
        get {
            return object.object(for: field.rawValue)!
        }
    }
    {% endif %}
    {% if t.name|hasSuffix:".ObjectIdField" %}
    // subscript(field: ObjectIdField) -> Object {
    //     set(newValue) {
    //         if let keyref = object.keyRef(for: field.rawValue) {
    //             object[keyref] = newValue
    //         } else {
    //             let keyref = KeyRef(value: field.rawValue, annotation: nil)
    //             object[keyref] = newValue
    //         }
    //     }
    //     get {
    //         return objects.object(for: object.string(for: field.rawValue)!)!
    //     }
    // }
    {% endif %}
    {% if t.name|hasSuffix:".OptionalStringField" %}
    subscript(field: OptionalStringField) -> String? {
        set(newValue) {
            if let keyref = object.keyRef(for: field.rawValue) {
                if let newValue = newValue {
                    let existing = object[keyref] as! StringValue
                    existing.value = newValue
                    object[keyref] = existing
                } else {
                    object[keyref] = nil
                }
            } else {
                let keyref = KeyRef(value: field.rawValue, annotation: nil)
                object[keyref] = newValue
            }
        }
        get {
            return object.string(for: field.rawValue)
        }
    }
    {% endif %}
    {% if t.name|hasSuffix:".OptionalArrayField" %}
    subscript(field: OptionalArrayField) -> [StringValue]? {
        set(newValue) {
            if let keyref = object.keyRef(for: field.rawValue) {
                if let newValue = newValue {
                    let existing = object[keyref] as! ArrayValue
                    existing.value = newValue
                    object[keyref] = existing
                } else {
                    object[keyref] = nil
                }
            } else {
                let keyref = KeyRef(value: field.rawValue, annotation: nil)
                object[keyref] = newValue
            }
        }
        get {
            return object.arrayValue(for: field.rawValue)?.value
        }
    }
    {% endif %}
    {% if t.name|hasSuffix:".OptionalObjectField" %}
    subscript(field: OptionalObjectField) -> Object? {
        set(newValue) {
            if let keyref = object.keyRef(for: field.rawValue) {
                object[keyref] = newValue
            } else {
                let keyref = KeyRef(value: field.rawValue, annotation: nil)
                object[keyref] = newValue
            }
        }
        get {
            return object.object(for: field.rawValue)
        }
    }
    {% endif %}

    {% for c in t.cases %}
    {% if c.name != "nop" %}
    {% if t.name|hasSuffix:".RawRepresentableField" %}
    subscript(field: RawRepresentableField) -> {{ c.name|upperFirst }} {
        set(newValue) {
            if let keyref = object.keyRef(for: field.rawValue) {
                object[keyref] = newValue.rawValue
            } else {
                let keyref = KeyRef(value: field.rawValue, annotation: nil)
                object[keyref] = newValue.rawValue
            }
        }
        get {
            return {{ c.name|upperFirst }}(rawValue: object.string(for: field.rawValue)!)!
        }
    }
    {% endif %}
    {% if t.name|hasSuffix:".StringField" %}
    public var {{ c.name }}: String {
        get { return self[.{{ c.name }}] }
        set(newValue) { self[.{{ c.name }}] = newValue }
    }
    {% endif %}
    {% if t.name|hasSuffix:".ArrayField" %}
    public var {{ c.name }}: [StringValue] {
        get { return self[.{{ c.name }}] }
        set(newValue) { self[.{{ c.name }}] = newValue }
    }
    {% endif %}
    {% if t.name|hasSuffix:".ObjectField" %}
    public var {{ c.name }}: Object {
        get { return self[.{{ c.name }}] }
        set(newValue) { self[.{{ c.name }}] = newValue }
    }
    {% endif %}
    {% if t.name|hasSuffix:".ObjectsReferencingField" %}
    {% if type.implements.ObjectsReferencing %}
    public var {{ c.name }}: {{ c.name|upperFirst }} {
        let id = object.string(for: "{{ c.name }}")!
        return {{ c.name|upperFirst }}(object: objects.object(for: id)!, objects: objects)
    }
    {% endif %}
    {% endif %}
    {% if t.name|hasSuffix:".OptionalStringField" %}
    public var {{ c.name }}: String? {
        get { return self[.{{ c.name }}] }
        set(newValue) { self[.{{ c.name }}] = newValue }
    }
    {% endif %}
    {% if t.name|hasSuffix:".OptionalArrayField" %}
    public var {{ c.name }}: [StringValue]? {
        get { return self[.{{ c.name }}] }
        set(newValue) { self[.{{ c.name }}] = newValue }
    }
    {% endif %}
    {% if t.name|hasSuffix:".OptionalObjectField" %}
    public var {{ c.name }}: Object? {
        get { return self[.{{ c.name }}] }
        set(newValue) { self[.{{ c.name }}] = newValue }
    }
    {% endif %}
    {% endif %}
    {% endfor %}

{% endif %}
{% endfor %}
}
{% endfor %}
